## 1. Java调用本地代码常见的两种方案

- JNI

JNI（Java Native Interface），有过不同语言间通信开发经历的一般都知道，它允许java和其他语言代码（尤其是C/C++）进行交互，只要遵守约定即可。首先看下JNI调用C/C++过程，注意写程序时自下而上，调用时自上而下：

![](https://files.mdnice.com/user/34714/8d5fb7fe-595c-437a-a343-7d85f879b726.png)

可见步骤之多，调用.dll/.so共享库之痛苦的过程。

若已有编译好的.dll/.so文件 **—>** 需先用是C语言另外写一个.dll/.so共享库，使用SUN规定的数据结构代替C语言的数据结构，调用已有的dll/so中公布的函数 **—>** java中载入这个库 **—>** java编写Native函数作为链接库中函数的代理

问题是很少有java程序员愿意编写调用.dll/.so库中原生函数的java程序，这也使java在客户端上乏善可言，是JNI的一大弱点！

- JNA

JNA提供一组Java工具类用于在运行期间动态访问系统本地库（native library：如Window的dll）而不需要编写任何Native/JNI代码。开发人员只要在一个java接口中描述目标native library的函数与结构，JNA将自动实现Java接口到native function的映射。

简而言之，就是jna基于jni的方式封装了很多api，在使用上面相对于jni来说简化了很多。

![](https://files.mdnice.com/user/34714/0084bcce-1ae8-4812-812b-39abbcbae297.png)

但是JNA不能完全替代JNI，JNI不仅可以实现java访问C，也可实现C调用java。

而JNA只能实现Java访问C函数，作为一个Java框架，自然不能实现C语言调用Java代码。此时，有些情况还是需要使用JNI技术。

# 2. 安装VS2022

- 下载 VS2022

下载 VS2022 时，现在社区版即可。

```
https://visualstudio.microsoft.com/zh-hans/vs/
```

![](https://files.mdnice.com/user/34714/e39864cc-4081-4d06-96ad-42af465dc21b.png)

下载下来是一个在线安装的安装器`VisualStudioSetup.exe`，双击运行即可。安装选择 **使用C++的桌面开发** 即可：

![](https://files.mdnice.com/user/34714/0b9843ee-a460-4b72-a397-092e692b5960.png)


## 3. 创建java项目

编写本地方法

```
public class JniDemo {

	 // 声明本地方法
    public native int add(int a, int b);
    
    public native int sub(int a, int b);
    
}    
```
使用`javah`生成c/c++头文件

```
javah com.jnidemo.JniDemo
```

![](https://files.mdnice.com/user/34714/f5d9d5db-f57b-4737-b4bd-7b510b2239f2.png)

生成的头文件`com_jnidemo_JniDemo.h`

```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_jnidemo_JniDemo */

#ifndef _Included_com_jnidemo_JniDemo
#define _Included_com_jnidemo_JniDemo
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_jnidemo_JniDemo
 * Method:    add
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_com_jnidemo_JniDemo_add
  (JNIEnv *, jobject, jint, jint);

/*
 * Class:     com_jnidemo_JniDemo
 * Method:    sub
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_com_jnidemo_JniDemo_sub
  (JNIEnv *, jobject, jint, jint);

/*
 * Class:     com_jnidemo_JniDemo
 * Method:    acl
 * Signature: ()D
 */
JNIEXPORT jdouble JNICALL Java_com_jnidemo_JniDemo_acl
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif

```

## 4. 创建c/c++项目

打开VS2022，创建动态链接库dll项目

![](https://files.mdnice.com/user/34714/91a17452-94c5-409e-ae7b-455e85f474da.png)

输入项目名和存储的目录，点击创建即可

![](https://files.mdnice.com/user/34714/5ce32ab2-ac1b-4354-9755-35d18d04656c.png)

把头文件`com_jnidemo_JniDemo.h`拷贝到JniTestDemo项目中，并附加到项目里

![](https://files.mdnice.com/user/34714/104336c1-d971-42d7-9250-28da995842bd.png)


![](https://files.mdnice.com/user/34714/a97216dd-0b18-418d-b50c-b7645c268f0a.png)


![](https://files.mdnice.com/user/34714/960e7dcd-2389-40a5-81d6-9a5bbaa75166.png)

创建`com_jnidemo_JniDemo.cpp`源文件，并实现头文件的两个定义的方法

```
#include "pch.h"
#include <jni.h>
#include "com_jnidemo_JniDemo.h"

/*
* Class:     com_jnidemo_JniDemo
* Method : add
* Signature : (II)I
*/
JNIEXPORT jint JNICALL Java_com_jnidemo_JniDemo_add(JNIEnv * env, jobject jobj, jint a, jint b){
	return a + b;
}

/*
 * Class:     com_jnidemo_JniDemo
 * Method:    sub
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_com_jnidemo_JniDemo_sub(JNIEnv* env, jobject jobj, jint a, jint b){
	return a - b;
}
```

添加jdk的jni.h文件到项目中，进行依赖构建

右击项目，现在属性

![](https://files.mdnice.com/user/34714/083dc53d-773a-437b-97d0-49ed3a4d752c.png)


![](https://files.mdnice.com/user/34714/82d5827c-e02a-4379-8f59-da1c4bcbf2d8.png)

选择图中这两个目录，做为构建依赖目录；这两个目录分别存在`jni.h`和`jni_md.h`两个头文件

![](https://files.mdnice.com/user/34714/b4a1ee36-50d4-4412-93f8-1af3743ece2c.png)

构建c/c++项目

![](https://files.mdnice.com/user/34714/6da5d28b-c352-4b96-aa29-e0a05e28d232.png)

**另外要特别注意编译的dll的x86与x64一定要与JDK的版本对应，否则在java调用dll时会出现以下错误：**

```
 Can't load IA 32-bit .dll on a AMD 64-bit platform
```

![](https://files.mdnice.com/user/34714/0338a781-4fc2-4ce7-b04e-6964c900c69c.png)


# 5.编写java代码调用dll

```
package com.jnidemo;

public class JniDemo {

	 // 声明本地方法
    public native int add(int a, int b);
    
    public native int sub(int a, int b);
    
    static {
    	System.out.println(System.getProperty("java.library.path"));
    	// x64
    	 System.load("E:\\dllws\\JniTestDemo\\x64\\Debug\\JniTestDemo.dll");
    }
    
    public static void main(String[] args) {
    	JniDemo ob = new JniDemo();
    	System.out.println(ob.add(1, 2));
    	System.out.println(ob.sub(2, 3));
	}
    
}

```

![](https://files.mdnice.com/user/34714/792793fe-92b4-4823-8427-6a76f76fb052.png)

# 6. 加载dll&so库文件的路径java.library.path说明

- Java的`System.load`和`System.loadLibrary`都可以用来加载库文件。例如可以这样载入一个windows平台下JNI库文件：
```
System.load("D://dll//TestJNI.dll"); //绝对路径
```

 - `System.loadLibrary`参数为库文件名
 
例如可以这样载入一个windows平台下JNI库文件

```
System.loadLibrary ("TestJNI");
```

这里TestJNI必须在`java.library.path`这一jvm变量所指向的路径中，可以通过如下方法获得该变量的值：

```
System.getProperty("java.library.path");
```

默认情况下，Windows平台下包含下面的路径：

  1）和jre相关的目录
  
  2）程序当前目录
  
  3）Windows目录
  
  4）系统目录(system32)
  
  5）系统环境变量path指定的目录
  
- 在linux下添加一个`java.library.path`的方法如下：
  在`/etc/profile`后面加上一行 
  
```
export LB_LIBRARY_PATH=路径
```

- 在执行程序的时候可以显示指定，`-Djava.library.path=路径`，这种会清除掉预设置的`java.library.path`的值。

```
java -jar -Djava.library.path=/usr/lib TestJni.jar
```
